from pdfminer.pdfparser import PDFParser
from pdfminer.pdfdocument import PDFDocument
from pdfminer.pdftypes import resolve1
import xml.etree.ElementTree as ET
import re
import json


class AcroFormParsingService:
    def __init__(self, pdf):
        parser = PDFParser(pdf)
        doc = PDFDocument(parser)
        acroform = resolve1(doc.catalog["AcroForm"])
        if 'XFA' in acroform.keys():
            xfa = acroform["XFA"]
            objs = [resolve1(x).get_data().decode() for n, x in enumerate(xfa) if n % 2 == 1]
            xstr = "".join(objs)
            xml_root = ET.fromstring(xstr)
            print(self.process_xfa_estars(xml_root))
        elif 'Fields' in acroform.keys():
            print(self.read_form_fields(acroform))
        else:
            pass

    def read_form_fields(self, acroform):
        result = {}
        for fld in resolve1(acroform['Fields']):
            item = resolve1(fld)
            fieldname = item['T'].decode("utf-8")
            data = None if 'V' not in item.keys() else item['V'].decode("utf-8")
            result[fieldname] = data
        return result

    def clean_name(self, s, n=50):
        result = s.lower()
        result = re.sub("[^a-z0-9]+", " ", result)
        result = re.sub("\s+", "_", result.strip())
        return result[:n]

    def xfa_get_fields_from_template(self, elem, namespaces, result={}, parent=None):
        """
        :param elem:
        :param namespaces:
        :param result:
        :param parent:

        Recursively parses a template namespace tree from an XFA document, extracting all necessary child elements
        (presently forms, subforms, and fields)
        """

        tag_name = elem.tag.split("}")[-1]
        elem_name = tag_name if "name" not in elem.attrib.keys() else elem.attrib["name"]
        if (
                tag_name == "subform"
        ):  # if tag is a subform save its name as the parent of subsequent fields
            parent = (
                None
                if elem_name == "root"
                else elem_name
                if parent is None
                else f"{parent}.{elem_name}"
            )
        elif tag_name == "field":  # if the tag is a field tag...
            # ignore uninteresting element types
            if (
                    not re.search("add", elem_name.lower())
                    and not re.search("delete", elem_name.lower())
                    and not re.search("attachment", elem_name.lower())
                    and not re.search("example", elem_name.lower())
                    and not re.search("tips", elem_name.lower())
            ):
                name = ""
                name_tags = [
                    "caption",
                    "toolTip",
                ]  # field info can come from one of two places
                for tag in name_tags:
                    cur = elem.find(f".//template:{tag}", namespaces)
                    if cur is not None:
                        if not len(
                                name
                        ):  # pull the field name and text from the element text...unless the field name was already found in the other tag type
                            name = "".join(cur.itertext())
                            name_tag = tag

                # save field metadata to dictionary
                if len(name):
                    result[elem_name] = {
                        "section": parent,
                        "field_name": elem_name,
                        "name": name,
                        "name_tag": name_tag,
                    }
                    # parse dropdown list values, if necessary
                    items = elem.findall(".//template:items", namespaces)
                    if len(items) == 2:
                        result[elem_name]["items"] = dict(
                            zip(list(items[1].itertext()), list(items[0].itertext()))
                        )

        # see if there are subelements and recurse into them if necessary
        subs = elem.findall("*", namespaces)
        if len(subs):
            for item in subs:
                result = self.xfa_get_fields_from_template(item, namespaces, result, parent)
        return result

    def get_fields_from_dataset(self, fields, datasets, namespaces):
        """
        :param fields:
        :param datasets:
        :param namespaces:

        Reads the field list generated by xfa_get_fields_from_template(), finds each of the fields in the dataset namespace, and extracts the vield value
        """
        for field_name, field in fields.items():
            elem = datasets.findall(f".//{field_name}")
            if elem is not None:
                for item in elem:
                    if item.text is not None:
                        if "items" in fields[field_name].keys() and len(
                                fields[field_name]["items"].keys()
                        ):
                            val = (
                                item.text
                                if item.text not in fields[field_name]["items"].keys()
                                else fields[field_name]["items"][item.text]
                            )
                        else:
                            val = item.text
                        if "value" in fields[field_name].keys():
                            if not isinstance(fields[field_name]["value"], list):
                                fields[field_name]["value"] = [fields[field_name]["value"]]
                            fields[field_name]["value"].append(val)
                        else:
                            fields[field_name]["value"] = val
        return fields

    def process_xfa_estars(self, root):
        # open PDF file and extract XFA form data as an XML string
        # Parse XFA XML
        namespaces = {}
        for elem in list(root):
            ns, tag = re.match("\{(.+)\}(.+)", elem.tag).groups()
            namespaces[tag] = ns

        # Get fields from template namespace
        template = root.find(".//template:template", namespaces)
        t_fields = self.xfa_get_fields_from_template(template, namespaces)

        # Get form values from dataset namespace
        datasets = root.find(".//datasets:datasets", namespaces)
        d_fields = self.get_fields_from_dataset(t_fields, datasets, namespaces)

        # Create list of field values and return dict result
        column_names = [
            field["field_name"] for field in d_fields.values() if "value" in field.keys()
        ]
        cell_values = {
            field["field_name"]: field["value"]
            for field in d_fields.values()
            if "value" in field.keys()
        }

        result = {
            "form_id": doc_id,
            "form_pages": pages,
            "tot_columns": len(column_names),
            "column_names": column_names,
            "cell_values": json.dumps(cell_values),
            "bucket_name": bucket,
            "object_key": doc_id,
        }

        return result
